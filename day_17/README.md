This is probably the problem that I learned the most from besides day 24, since I had to first learn about the petgraph library, and then I had to implement my own version of dijkstra's algorithm. The issue is that the program is underestimating the answer. 

Truth be told, I've tried debugging this for a while, and still can't get the program to produce the correct answer for the example (it's too low). The best lead I've got is that when nodes are at the front of the priority queue, they don't seem to have a weight that matches the cumulative weight of the shortest path to the endpoint given in the puzzle. For example, the node at (0,5) has a weight of 22 when it's the lowest in the priority queue, but if it follows the shortest path to the endpoint, it should be 23. I think this is because the turn that creates the less weighty nodes then obligates the path to go through heavier weights down the line. That makes sense, but then it makes me wonder why dijkstra should ever work to solve this problem to begin with â€“ I thought that the algorithm presumes that shortest path to any given point is made up of the shortest paths to any of its consituents.

Even given this, it's odd that it's producing answers that are too low. You'd think that if I were just not modifying dijkstra to accommodate the movement constraint correctly, it would be producing paths that were shorter to intermediate nodes, but longer to the finish. I checked that my weights are being set correctly and didn't find anything

This is the problem that I'm most inclined to return to at some point, but for now I need to put this aside.